#include "CmdMediator.h"
#include "CmdSettingsDigitizeCurve.h"
#include "DlgSettingsDigitizeCurve.h"
#include "DocumentModelDigitizeCurve.h"
#include "EngaugeAssert.h"
#include "Logger.h"
#include "MainWindow.h"
#include "PointStyle.h"
#include <QBitmap>
#include <QCheckBox>
#include <QComboBox>
#include <QGraphicsPixmapItem>
#include <QGridLayout>
#include <QGraphicsScene>
#include <QLabel>
#include <qmath.h>
#include <QPixmap>
#include <QRadioButton>
#include <QSpinBox>
#include "Segment.h"
#include "SegmentFactory.h"
#include "ViewPreview.h"

const int IMAGE_WIDTH = 100;
const int IMAGE_HEIGHT = 100;

DlgSettingsDigitizeCurve::DlgSettingsDigitizeCurve(MainWindow &mainWindow) :
  DlgSettingsAbstractBase ("Digitize Curve",
                           "DlgSettingsDigitizeCurve",
                           mainWindow),
  m_scenePreview (0),
  m_viewPreview (0),
  m_modelDigitizeCurveBefore (0),
  m_modelDigitizeCurveAfter (0)
{
  LOG4CPP_INFO_S ((*mainCat)) << "DlgSettingsDigitizeCurve::DlgSettingsDigitizeCurve";

  QWidget *subPanel = createSubPanel ();
  finishPanel (subPanel);
}

DlgSettingsDigitizeCurve::~DlgSettingsDigitizeCurve()
{
  LOG4CPP_INFO_S ((*mainCat)) << "DlgSettingsDigitizeCurve::~DlgSettingsDigitizeCurve";
}

const int INNER_RADIUS_MAX = 64;
const int INNER_RADIUS_MIN = 0;
const int LINE_LENGTH_MAX = 64;
const int LINE_LENGTH_MIN = 2;
const int LINE_WIDTH_MAX = 32;
const int LINE_WIDTH_MIN = 1;

void DlgSettingsDigitizeCurve::createControls (QGridLayout *layout,
                                               int &row)
{
  LOG4CPP_INFO_S ((*mainCat)) << "DlgSettingsDigitizeCurve::createControls";

  QLabel *labelCursorType = new QLabel("Cursor type:");
  layout->addWidget (labelCursorType, row, 1);

  m_btnCursorStandard = new QRadioButton ("Standard cross");
  layout->addWidget (m_btnCursorStandard, row++, 2);
  connect (m_btnCursorStandard, SIGNAL (toggled (bool)), this, SLOT (slotCursorStandard(bool)));

  m_btnCursorCustom = new QRadioButton ("Custom cross");
  layout->addWidget (m_btnCursorCustom, row++, 2);
  connect (m_btnCursorCustom, SIGNAL (toggled (bool)), this, SLOT (slotCursorCustom(bool)));

  QLabel *labelInnerRadius = new QLabel("Inner radius (pixels):");
  layout->addWidget (labelInnerRadius, row, 1);

  m_spinInnerRadius = new QSpinBox;
  m_spinInnerRadius->setRange (INNER_RADIUS_MIN, INNER_RADIUS_MAX);
  m_spinInnerRadius->setWhatsThis (tr ("Radius of circle at the center of the cursor that will remain empty"));
  layout->addWidget (m_spinInnerRadius, row++, 2);
  connect (m_spinInnerRadius, SIGNAL (valueChanged(const QString &)), this, SLOT (slotCursorInnerRadius (const QString &)));

  QLabel *labelLineLength = new QLabel("Line length (pixels):");
  layout->addWidget (labelLineLength, row, 1);

  m_spinLineLength = new QSpinBox;
  m_spinLineLength->setRange (LINE_LENGTH_MIN, LINE_LENGTH_MAX);
  m_spinLineLength->setWhatsThis (tr ("Length of each arm of the cross of the cursor"));
  layout->addWidget (m_spinLineLength, row++, 2);
  connect (m_spinLineLength, SIGNAL (valueChanged(const QString &)), this, SLOT (slotCursorLineLength (const QString &)));

  QLabel *labelLineWidth = new QLabel("Line width (pixels):");
  layout->addWidget (labelLineWidth, row, 1);

  m_spinLineWidth = new QSpinBox;
  m_spinLineWidth->setRange (LINE_WIDTH_MIN, LINE_WIDTH_MAX);
  m_spinLineWidth->setWhatsThis (tr ("Width of each arm of the cross of the cursor"));
  layout->addWidget (m_spinLineWidth, row++, 2);
  connect (m_spinLineWidth, SIGNAL (valueChanged(const QString &)), this, SLOT (slotCursorLineWidth (const QString &)));
}

void DlgSettingsDigitizeCurve::createPreview (QGridLayout *layout,
                                         int &row)
{
  LOG4CPP_INFO_S ((*mainCat)) << "DlgSettingsDigitizeCurve::createPreview";

  QLabel *labelPreview = new QLabel ("Preview");
  layout->addWidget (labelPreview, row++, 0, 1, 4);

  m_scenePreview = new QGraphicsScene (this);
  m_scenePreview->setSceneRect(0,
                               0,
                               IMAGE_WIDTH,
                               IMAGE_HEIGHT);

  m_viewPreview = new ViewPreview (m_scenePreview, this);
  m_viewPreview->setWhatsThis (tr ("Preview window shows the shortest line that can be segment filled, "
                                   "and the effects of current settings on segments and points generated by segment fill"));
  m_viewPreview->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
  m_viewPreview->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
  m_viewPreview->setMinimumHeight (MINIMUM_PREVIEW_HEIGHT);

  layout->addWidget (m_viewPreview, row++, 0, 1, 4);
}

QWidget *DlgSettingsDigitizeCurve::createSubPanel ()
{
  LOG4CPP_INFO_S ((*mainCat)) << "DlgSettingsDigitizeCurve::createSubPanel";

  QWidget *subPanel = new QWidget ();
  QGridLayout *layout = new QGridLayout (subPanel);
  subPanel->setLayout (layout);

  layout->setColumnStretch (0, 1); // Empty first column
  layout->setColumnStretch (1, 0); // Labels
  layout->setColumnStretch (2, 0); // User controls
  layout->setColumnStretch (3, 1); // Empty last column

  int row = 0;
  createControls(layout, row);
  createPreview (layout, row);

  return subPanel;
}

void DlgSettingsDigitizeCurve::handleOk ()
{
  LOG4CPP_INFO_S ((*mainCat)) << "DlgSettingsDigitizeCurve::handleOk";

  CmdSettingsDigitizeCurve *cmd = new CmdSettingsDigitizeCurve (mainWindow (),
                                                                cmdMediator ().document(),
                                                                *m_modelDigitizeCurveBefore,
                                                                *m_modelDigitizeCurveAfter);
  cmdMediator ().push (cmd);

  hide ();
}

void DlgSettingsDigitizeCurve::load (CmdMediator &cmdMediator)
{
  LOG4CPP_INFO_S ((*mainCat)) << "DlgSettingsDigitizeCurve::load";

  setCmdMediator (cmdMediator);

  // Flush old data
  if (m_modelDigitizeCurveBefore != 0) {
    delete m_modelDigitizeCurveBefore;
  }
  if (m_modelDigitizeCurveAfter != 0) {
    delete m_modelDigitizeCurveAfter;
  }

  // Save new data
  m_modelDigitizeCurveBefore = new DocumentModelDigitizeCurve (cmdMediator.document());
  m_modelDigitizeCurveAfter = new DocumentModelDigitizeCurve (cmdMediator.document());

  // Sanity checks. Incoming defaults must be acceptable to the local limits
  ENGAUGE_ASSERT (INNER_RADIUS_MIN <= m_modelDigitizeCurveAfter->cursorInnerRadius ());
  ENGAUGE_ASSERT (INNER_RADIUS_MAX >= m_modelDigitizeCurveAfter->cursorInnerRadius ());
  ENGAUGE_ASSERT (LINE_LENGTH_MIN <= m_modelDigitizeCurveAfter->cursorLineLength ());
  ENGAUGE_ASSERT (LINE_LENGTH_MAX >= m_modelDigitizeCurveAfter->cursorLineLength ());
  ENGAUGE_ASSERT (LINE_WIDTH_MIN <= m_modelDigitizeCurveAfter->cursorLineWidth ());
  ENGAUGE_ASSERT (LINE_WIDTH_MAX >= m_modelDigitizeCurveAfter->cursorLineWidth ());

  // Populate controls
  m_btnCursorStandard->setChecked (m_modelDigitizeCurveAfter->cursorStandardCross());
  m_btnCursorCustom->setChecked (!m_modelDigitizeCurveAfter->cursorStandardCross());
  m_spinInnerRadius->setValue (m_modelDigitizeCurveAfter->cursorInnerRadius());
  m_spinLineLength->setValue (m_modelDigitizeCurveAfter->cursorLineLength());
  m_spinLineWidth->setValue (m_modelDigitizeCurveAfter->cursorLineWidth());

  updateControls();
  enableOk (false); // Disable Ok button since there not yet any changes
  updatePreview();
}

void DlgSettingsDigitizeCurve::slotCursorCustom (bool)
{
  LOG4CPP_INFO_S ((*mainCat)) << "DlgSettingsDigitizeCurve::slotCursorCustom";

  m_modelDigitizeCurveAfter->setCursorStandardCross(false);
  updateControls();
  updatePreview();
}

void DlgSettingsDigitizeCurve::slotCursorInnerRadius (const QString &)
{
  LOG4CPP_INFO_S ((*mainCat)) << "DlgSettingsDigitizeCurve::slotCursorInnerRadius";

  m_modelDigitizeCurveAfter->setCursorInnerRadius (m_spinInnerRadius->value());
  updateControls();
  updatePreview();
}

void DlgSettingsDigitizeCurve::slotCursorLineLength (const QString &)
{
  LOG4CPP_INFO_S ((*mainCat)) << "DlgSettingsDigitizeCurve::slotCursorLineLength";

  m_modelDigitizeCurveAfter->setCursorLineLength (m_spinLineLength->value());
  updateControls();
  updatePreview();
}

void DlgSettingsDigitizeCurve::slotCursorLineWidth (const QString &)
{
  LOG4CPP_INFO_S ((*mainCat)) << "DlgSettingsDigitizeCurve::slotCursorLineWidth";

  m_modelDigitizeCurveAfter->setCursorLineWidth (m_spinLineWidth->value());
  updateControls();
  updatePreview();
}

void DlgSettingsDigitizeCurve::slotCursorStandard (bool)
{
  LOG4CPP_INFO_S ((*mainCat)) << "DlgSettingsDigitizeCurve::slotCursorStandard";

  m_modelDigitizeCurveAfter->setCursorStandardCross(true);
  updateControls();
  updatePreview();
}

void DlgSettingsDigitizeCurve::updateControls()
{
  enableOk (true);

  m_spinInnerRadius->setEnabled (m_btnCursorCustom->isChecked());
  m_spinLineLength->setEnabled (m_btnCursorCustom->isChecked());
  m_spinLineWidth->setEnabled (m_btnCursorCustom->isChecked());
}

void DlgSettingsDigitizeCurve::updatePreview()
{
  LOG4CPP_INFO_S ((*mainCat)) << "DlgSettingsDigitizeCurve::updatePreview";

  // To prevent hideous drawing errors when the line is thicker, we
  // leave a padding region around the outside equal in size to the line width
  int innerRadius = m_modelDigitizeCurveAfter->cursorInnerRadius();
  int lineLength = m_modelDigitizeCurveAfter->cursorLineLength();
  int lineWidth = m_modelDigitizeCurveAfter->cursorLineWidth();
  int halfLineWidth = lineWidth / 2;
  int halfHeightAndWidth = innerRadius + lineLength + lineWidth;
  int heightAndWidth = 2 * halfHeightAndWidth;

  if (m_btnCursorStandard->isChecked()) {

    // Standard cursor
    m_viewPreview->setCursor (QCursor (Qt::CrossCursor));

  } else {

    // Custom cursor
    const int BACKGROUND_COLOR = Qt::white, FOREGROUND_COLOR = Qt::black;

    // Cursor is created with pic image (which has nontrivial pen) masked by picMask image
    // (which has single color pen)
    QPixmap picMask (heightAndWidth,
                     heightAndWidth);
    QPainter picMaskPaint (&picMask);
    picMask.fill (QColor (BACKGROUND_COLOR));

    QPen pen (QBrush (FOREGROUND_COLOR),
              m_modelDigitizeCurveAfter->cursorLineWidth());
    picMaskPaint.setPen (pen);

    picMaskPaint.drawLine (QPointF (halfHeightAndWidth,
                                    halfHeightAndWidth - innerRadius - halfLineWidth),
                           QPointF (halfHeightAndWidth,
                                    lineWidth)); // Up
    picMaskPaint.drawLine (QPointF (halfHeightAndWidth - innerRadius - halfLineWidth,
                                    halfHeightAndWidth),
                           QPointF (lineWidth,
                                    halfHeightAndWidth)); // Left
    picMaskPaint.drawLine (QPointF (halfHeightAndWidth,
                                    halfHeightAndWidth + innerRadius + halfLineWidth),
                           QPointF (halfHeightAndWidth,
                                    heightAndWidth - 1 - lineWidth)); // Down
    picMaskPaint.drawLine (QPointF (halfHeightAndWidth + innerRadius + halfLineWidth,
                                    halfHeightAndWidth),
                           QPointF (heightAndWidth - 1 - lineWidth,
                                    halfHeightAndWidth)); // Right

    QPixmap pic (heightAndWidth,
                 heightAndWidth);
    pic.fill (QColor (FOREGROUND_COLOR));

    QCursor cursor (pic.createMaskFromColor(QColor (BACKGROUND_COLOR)),
                    picMask.createMaskFromColor(QColor (BACKGROUND_COLOR)));
    m_viewPreview->setCursor (cursor);
  }
}
